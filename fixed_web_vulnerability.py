
import requests
import re
from bs4 import BeautifulSoup
from urllib.parse import urljoin, parse_qs, urlparse
import json
import logging
from concurrent.futures import ThreadPoolExecutor
import datetime
import warnings
import urllib3
from typing import Dict, List, Any

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class WebSecurityScanner:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.discovered_urls = set()
        self.vulnerable_endpoints = []
        self.extracted_data = {
            'users': [],
            'credit_cards': [],
            'api_keys': [],
            'customer_data': [],
            'emails': [],
            'passwords': []
        }
        self.setup_logging()

    def setup_logging(self):
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)

    def discover_urls(self):
        try:
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, "html.parser")

            for anchor in soup.find_all("a"):
                href = anchor.get("href")
                if href:
                    self.add_url(href)

            scripts = soup.find_all("script")
            for script in scripts:
                if script.string:
                    api_patterns = [
                        r'fetch\(["\']([^"\']+)["\']\)',
                        r'axios\.[a-z]+\(["\']([^"\']+)["\']\)',
                        r'url:\s*["\']([^"\']+)["\']'
                    ]
                    for pattern in api_patterns:
                        matches = re.findall(pattern, script.string)
                        for match in matches:
                            self.add_url(match)

            # Fallback to hardcoded endpoints if discovery fails
            self.discovered_urls.update([
                urljoin(self.base_url, "/api/user"),
                urljoin(self.base_url, "/api/customer"),
                urljoin(self.base_url, "/api/comments"),
                urljoin(self.base_url, "/api/debug")
            ])

        except Exception as e:
            self.logger.error(f"Error during URL discovery: {str(e)}")

    def add_url(self, url):
        full_url = urljoin(self.base_url, url)
        if full_url.startswith(self.base_url):
            self.discovered_urls.add(full_url)

    def scan_vulnerabilities(self):
        with ThreadPoolExecutor(max_workers=5) as executor:
            executor.map(self.scan_single_url, self.discovered_urls)

    def scan_single_url(self, url):
        self.logger.info(f"Scanning: {url}")
        vulnerabilities = []

        if self.test_sql_injection(url):
            vulnerabilities.append({
                "type": "SQL Injection",
                "url": url,
                "details": "Endpoint appears vulnerable to SQL injection attacks"
            })

        if self.test_xss(url):
            vulnerabilities.append({
                "type": "Cross-Site Scripting (XSS)",
                "url": url,
                "details": "Endpoint appears vulnerable to XSS attacks"
            })

        if self.test_information_disclosure(url):
            vulnerabilities.append({
                "type": "Information Disclosure",
                "url": url,
                "details": "Endpoint leaks sensitive information"
            })

        if vulnerabilities:
            self.vulnerable_endpoints.extend(vulnerabilities)

    def test_sql_injection(self, url):
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
            "' UNION SELECT username,password,email,credit_card,api_key FROM users--",
            "' UNION SELECT id,name,address,phone,ssn FROM customer_data--"
        ]
        for payload in payloads:
            try:
                if '/api/customer' in url:
                    params = {'name': payload}  # Correct parameter for `/api/customer`
                else:
                    params = {'username': payload}  # Correct parameter for `/api/user`
                response = self.session.get(url, params=params)
                if response.status_code == 200 and payload in response.text:
                    return True
            except Exception as e:
                self.logger.debug(f"SQL injection test error: {str(e)}")
        return False

    def test_xss(self, url):
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')"
        ]
        for payload in xss_payloads:
            try:
                if '/api/comments' in url:
                    # Use POST for /api/comments
                    response = self.session.post(url, data={"comment": payload})
                else:
                    # Use GET for other endpoints
                    response = self.session.get(url, params={"comment": payload})
                if payload in response.text:
                    return True
            except Exception as e:
                self.logger.debug(f"XSS test error: {str(e)}")
        return False

    def test_information_disclosure(self, url):
        sensitive_patterns = [
            r"password[\s]*=[\s]*['\"][\w@#$%^&*()]+['\"]",
            r"api[_]key[\s]*=[\s]*['\"][\w]+['\"]",
            r"super_secret_key"
        ]
        try:
            response = self.session.get(url)
            for pattern in sensitive_patterns:
                if re.search(pattern, response.text, re.IGNORECASE):
                    return True
        except Exception as e:
            self.logger.debug(f"Information disclosure test error: {str(e)}")
        return False

    def generate_report(self):
        if not self.vulnerable_endpoints:
            return {
                "status": "secure",
                "message": "No vulnerabilities detected",
                "scan_details": {
                    "base_url": self.base_url,
                    "urls_scanned": len(self.discovered_urls),
                    "timestamp": datetime.datetime.now().isoformat()
                }
            }
        report = {
            "status": "vulnerable",
            "base_url": self.base_url,
            "scan_summary": {
                "total_urls_scanned": len(self.discovered_urls),
                "vulnerable_endpoints": len(self.vulnerable_endpoints),
                "scan_timestamp": datetime.datetime.now().isoformat()
            },
            "vulnerabilities": self.vulnerable_endpoints
        }
        self.generate_html_report(report)

    def generate_html_report(self, report_data):
        html_content = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Security Report</title>
        </head>
        <body>
            <h1>Security Report for {report_data['base_url']}</h1>
            <p>Total URLs Scanned: {report_data['scan_summary']['total_urls_scanned']}</p>
            <p>Vulnerable Endpoints: {report_data['scan_summary']['vulnerable_endpoints']}</p>
        </body>
        </html>
        """
        with open('security_report.html', 'w') as f:
            f.write(html_content)

if __name__ == "__main__":
    scanner = WebSecurityScanner("http://localhost:3000/")
    scanner.discover_urls()
    scanner.scan_vulnerabilities()
    scanner.generate_report()
